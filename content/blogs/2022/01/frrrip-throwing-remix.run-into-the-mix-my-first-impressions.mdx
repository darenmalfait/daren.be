---
seo:
  title: 'frrrip throwing remix.run into the mix: my first impressions'
  description: >-
    Remix.run is the (or not, to be confirmed) hot new Full Stack React
    framework around the block. A few knowledgeable engineers hype it at the
    moment.
title: frrrip throwing remix.run into the mix my first impressions
tags:
  - inspiration
category: technical
heroImg: >-
  https://res.cloudinary.com/darenmalfait/image/upload/v1667651534/ff1c533a-fd92-44a0-8f78-de6b2af987d8_scjfsk.jpg
excerpt: >
  remix.run is the (or not, to be confirmed) hot new Full Stack React framework
  around the block. It is hyped by a few knowledgeable engineers at the moment.
date: '2022-01-28T11:00:00.000Z'
_body: "remix.run is the (or not, to be confirmed) hot new Full Stack React framework around the block. A few knowledgeable engineers hype it at the moment. It should be noted that the founders [Michael Jackson](https://twitter.com/mjackson) and [Ryan Florence](https://twitter.com/ryanflorence) are mostly known for React Router, UNPKG, and Reach UI. Moreover,\_[Kent C. Dodds](https://twitter.com/kentcdodds)\_has recently joined the team as director of developer experience to throw some more wood on the fire. Many developers have used at least one or more things that they made.\n\nIn this post, I will be talking about the following:\n\n* Remix\n* Routes\n* Loaders\n* Client UI\n* Actions → I like this part\n* My opinion\n\n## About Remix\n\nThe entire idea behind Remix is that everything is server-rendered. As someone who has spent much time using things like [NextJS](https://nextjs.org/) and [Gatsby](https://www.gatsbyjs.com/), going mainly SSR is somewhat different.\n\nTo begin, their website says: Remix – Build better websites. Saying something like that lifts the expectations and raises the bar to a high level, especially when the competition for creating websites is enormous. NextJS, in particular, is probably the closest competitor for what Remix is trying to do. Moreover, I will not be comparing Remix with something like Gatsby, as Remix isn't a Static Site generator. Instead, the focus of Remix is server-side rendering, and even though you can use NextJS as an SSG, it has server rendering and does a lot of the same stuff Remix does, but differently.\n\n## Initial project setup\n\nI have mixed feelings about the initial setup. So let me carry you through this. Firstly, you do this in your terminal:\n\n![create-remix command](https://res.cloudinary.com/darenmalfait/image/upload/v1667651738/Screenshot_2022-01-29_at_00.13.28_tfjszh.png \"create-remix command\")\n\nFollowing this, you see a fancy Remix animation in the console and a menu where you need to choose where to deploy your application. Depending on your pick, you get a project with different configuration files pre-made for the platform you will deploy. On the one hand, if you want to change hosting, you need to think about what needs to change to run it on the other platform. On the other hand, it doesn't feel great.\n\nOn the other hand, it does save you configuration time, it's easy, and the animated logo in the terminal looks pretty. \U0001F937‍♂️ Let's talk about the essential thing about Remix.\n\n## Routes\n\nFirstly, routes are the most significant thing about Remix. To me, it feels like every route is a server route and conveniently has the option to render a client-side UI if you want. In essence, everything in Remix is about routes, and that's not a surprise if you look at the people that founded Remix.\n\n> Every route is a server route and conveniently has the option to render a client-side UI if you want.\n\nBasically, on every route, you have the option to export things. So, for example, you can render a front-end, get data from somewhere, generate an RSS feed, or submit a form based on those things.\n\nJust going over the basics, these are things you can expect from a route:\n\n```typescript\nexport {\n  loader,\n  meta,\n  handle,\n  action,\n  CatchBoundary,\n  ErrorBoundary,\n};\n\nexport default <div />\n```\n\nI'm not going to elaborate on the functionalities of Routes (nested routes, parameters, …), but those are things you want to take a look at once you know the basics.\n\n### Loader\n\nLoaders are the backbone of the route, as they do all the heavy lifting. Therefore, you want to return to everything related to the data you need in this function's front end.\n\nThe idea behind a loader is that you can do more than return data for a route. You can send complete responses, including cache control headers. When you set cache headers on your response, the same route will get the cache if the route has already been fetched.\n\nAn example of a loader:\n\n```typescript\nimport { json } from 'remix';\nimport type { LoaderFunction } from 'remix';\n\nexport const loader: LoaderFunction = async ({ request, params }) => {\n  const example = await getExampleData();\n\n  return json<LoaderData>(\n    { example },\n    { status: 200, headers: { 'Cache-Control': 'private, max-age=3600' } }\n  );\n}\n```\n\n## Client UI\n\nIf loaders are the backbone, the client-UI is the frontal bone. In particular, the part you export as default is where you render your front end. So if you have fetched some data inside your Loader, you can get it here and render it for your visitors.\n\nGetting the data from the Loader is pretty straightforward:\n\n```typescript\nexport default function ExamplePage() {\n  const { example } = useLoaderData<LoaderData>();\n\n  return <div>{ example } < /div>\n}\n```\n\nEverything else in the default export is basic JSX, putting components where you want them, and so on.\n\nAt this point, you could make your entire full-stack application with just these two things. In addition, RRemix makes the communication between the front- and back end pretty darn easy. You can fetch data from any API, and since it is server-side-rendered, you can fetch data with secret keys without worrying about exposing your secrets.\n\n> Remix makes the communication between the front- and back-end pretty darn easy.\n\n## Action\n\nLast but not least, actions. Actions are where things get interesting. Action is a server-only function where you can handle actions. It is the same as Loader; the only difference is when it's called. The action is called before the loaders if a non-GET request is made to your route (POST, PUT, PATCH, DELETE).\n\nFor example, an action could be submitting a form to subscribe to a newsletter.\n\nFirst, we create a simple form like this:\n\n```typescript\nimport { Form } from { remix }\n\nexport default function ContactFormRoute() {\n  <Form noValidate method = \"post\" >\n    <h2>Sign up for our newsletter < /h2>\n      < input name = \"email\" type = \"email\" />\n        <button>Subscribe < /button>\n        < /Form>\n}\n```\n\nRemix \\<Form> works identically to HTML \\<form>, with a few goodies. If JavaScript is turned off, the form will still work. Remember, the default form only supports GET en POST, so you should probably stick to those if you’re using a form.\n\nAnd then, we create a server-side Action to handle the form submission. When no \\`action\\` is provided to a form, it will submit to the page itself.\n\n```typescript\nexport const action: ActionFunction = async ({ request }) => {\n  if (request.method === 'POST') {\n    const formData = await request.formData()\n    const email = formData.get('email')\n\n    // handle server side validation\n    if (!email) {\n      return json({ errors: \"no email provided\" }, 500)\n    }\n\n    // subscribe login return 500 when things go wrong\n    return json({ ok: true }, 200)\n  }\n}\n```\n\nTo get back to the front end, you can receive the responses from the action in a few ways, one of them being useActionData.\n\n```typescript\nconst actionsData = useActionData()\n\nif (actionsData?.ok) return <div>success! < /div>\nif (actionsData?.errors) return <div>{ actionsData?.errors } < /div>\n```\n\nWhen a POST is made to a URL, multiple routes in your route hierarchy will match the URL. Unlike GET to loaders, where all of them are called to build the UI, only one action is called.\n\nForms without an action prop (\\<Form method=\"post\">) will automatically post to the same route within which they are rendered.\n\nMy first thought was: Oh, you can build an entire API like that. Nice. It’s the \\`/api\\` folder in NextJS (if you are familiar) but throughout the entire routing folder. Moreover, every route has the option to render a front end. That’s amazing.\n\nWith loaders and front-end rendering, you have all the basics to make an application. Everything else is improving the UX of the application.\n\n## Other stuff\n\nRemix doesn’t stop at Loaders and Actions. My first impressions do, however. If you want to know more about Remix (like nested routes, Error handling, and so much more), I would strongly suggest looking at their website: [https://www.remix.run](https://www.remix.run/).\n\n## My opinion about remix.run\n\nHonestly, I can say that I’m hyped. I am a fan of serverless and JAMStack, so I started sceptically. Remix.run, to me, feels like you are working inside a web framework, not a React framework. You so happen to be, are working with React on top of it. Moreover, I have learned about Javascript in my adventure learning Remix, and I’m not done using it. It is promising - without a doubt.\n\nIn conclusion, a lot of things make sense. Thinking about what happens on the server and what doesn’t is something extra to think about, but that might be a good thing.\n\nIf you are a fan of magic, I recommend you to stick to NextJS (or Gatsby for even more magic) or whatever framework you are using now. But if you like bare-boned where you have control over everything, Remix might be your tool.\n"
---

